<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idle Universe: The Omnidimensional Conflux</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #f3f4f6; /* text-gray-100 */
            overscroll-behavior: none; 
        }
        .font-arcade {
            font-family: 'Press Start 2P', cursive;
        }
        .domain-card {
            background-color: #1f2937; /* bg-gray-800 */
            border: 1px solid #374151; /* border-gray-700 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem; /* p-4 */
            margin-bottom: 1rem; /* mb-4 */
            transition: box-shadow 0.3s ease, outline 0.2s ease;
        }
        .domain-card:hover {
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5); /* shadow-indigo-500/50 */
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            font-weight: 500; /* font-medium */
            transition: background-color 0.2s ease, transform 0.1s ease;
            cursor: pointer;
            border: none;
            min-width: 80px; 
        }
        .btn-primary {
            background-color: #4f46e5; /* bg-indigo-600 */
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca; /* bg-indigo-700 */
        }
        .btn-primary:active {
            transform: scale(0.98);
        }
        .btn-secondary {
            background-color: #374151; /* bg-gray-700 */
            color: #d1d5db; /* text-gray-300 */
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* bg-gray-600 */
        }
        .btn-secondary:active {
            transform: scale(0.98);
        }
        .btn-disabled {
            background-color: #4b5563 !important; /* Ensure disabled style overrides */
            color: #9ca3af !important;
            cursor: not-allowed !important;
        }
        .resource-display {
            font-size: 0.875rem; /* text-sm */
            color: #9ca3af; /* text-gray-400 */
        }
        .story-log {
            background-color: #1f2937; /* bg-gray-800 */
            border: 1px solid #374151; /* border-gray-700 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.875rem; /* text-sm */
        }
        .story-log-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid #374151; /* border-gray-700 */
        }
        .story-log-entry:last-child {
            border-bottom: none;
        }
        .story-log::-webkit-scrollbar, #lore-modal-content::-webkit-scrollbar, .modal-content-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .story-log::-webkit-scrollbar-track, #lore-modal-content::-webkit-scrollbar-track, .modal-content-scroll::-webkit-scrollbar-track {
            background: #1f2937; /* bg-gray-800 */
            border-radius: 0.5rem;
        }
        .story-log::-webkit-scrollbar-thumb, #lore-modal-content::-webkit-scrollbar-thumb, .modal-content-scroll::-webkit-scrollbar-thumb {
            background: #4b5563; /* bg-gray-600 */
            border-radius: 0.5rem;
        }
        .story-log::-webkit-scrollbar-thumb:hover, #lore-modal-content::-webkit-scrollbar-thumb:hover, .modal-content-scroll::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* bg-gray-500 */
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: max-content;
            max-width: 250px;
            background-color: #111827; /* bg-gray-900 */
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is above overlays */
            bottom: 125%; 
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem; /* text-xs */
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .target-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 40; 
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
        }
        .domain-card.targetable:hover {
            outline: 2px solid #fbbf24; /* amber-400 */
            cursor: crosshair;
        }
        .stat-bar {
            height: 10px;
            background-color: #374151; /* bg-gray-700 */
            border-radius: 0.25rem; /* rounded-sm */
            overflow: hidden;
        }
        .stat-bar-fill {
            height: 100%;
            background-color: #ef4444; /* red-500 */
            transition: width 0.3s ease;
            border-radius: 0.25rem; /* rounded-sm */
        }
        /* Modal Styles (Generic) */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 50; /* Default modal z-index */
        }
        .modal-content-wrapper {
            background-color: #1f2937; /* bg-gray-800 */
            padding: 1.5rem; /* p-6 */
            border-radius: 0.5rem; /* rounded-lg */
            max-width: 42rem; /* max-w-2xl */
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); /* shadow-xl */
            border: 1px solid #374151; /* border-gray-700 */
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem; /* mb-4 */
        }
        .modal-title {
            font-size: 1.5rem; /* text-2xl */
            font-family: 'Press Start 2P', cursive;
            color: #818cf8; /* text-indigo-400 */
        }
        .modal-close-button {
            color: #9ca3af; /* text-gray-400 */
            font-size: 2.25rem; /* text-3xl */
            line-height: 1;
            font-weight: bold;
            background: none;
            border: none;
            cursor: pointer;
        }
        .modal-close-button:hover {
            color: white;
        }
        .modal-body {
            color: #d1d5db; /* text-gray-300 */
            font-size: 0.95rem;
        }
        .modal-body ul {
            list-style-type: disc;
            padding-left: 1.5rem;
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }
        .modal-body li {
            margin-bottom: 0.5rem;
        }
        .modal-body strong {
            color: #a5b4fc; /* indigo-300 */
        }
        /* Coach Mark Styles */
        .coach-mark-overlay {
            z-index: 1000; /* Must be on top of everything */
        }
        .coach-mark-highlight {
            outline: 3px solid #fcd34d; /* amber-300 */
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.65); /* Dim background */
            border-radius: 0.375rem; /* rounded-md, adjust as needed */
            position: relative; /* Needed for z-index to work with the shadow */
            z-index: 1001; /* Above the dimming overlay part */
            transition: outline 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
         .coach-mark-highlight-pulsate {
            animation: coachPulse 1.5s infinite;
        }
        @keyframes coachPulse {
            0% { outline-color: #fcd34d; } /* amber-300 */
            50% { outline-color: #fbbf24; } /* amber-400 */
            100% { outline-color: #fcd34d; }
        }
        .coach-mark-message-box {
            position: fixed;
            background-color: #111827; /* bg-gray-900 */
            color: #e5e7eb; /* text-gray-200 */
            padding: 1rem;
            border-radius: 0.5rem; /* rounded-lg */
            border: 2px solid #818cf8; /* indigo-400 */
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 1002; /* Above highlight */
            max-width: 300px;
            text-align: center;
        }
    </style>
</head>
<body class="min-h-screen p-2 sm:p-4 md:p-6">
    <div class="container mx-auto max-w-7xl">
        <header class="mb-6 text-center relative">
            <button id="help-button" class="btn btn-secondary absolute top-0 right-0 m-1 sm:m-2 text-sm font-arcade">Help (?)</button>
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-arcade text-indigo-400">Idle Universe</h1>
            <p class="text-lg sm:text-xl font-arcade text-indigo-200">The Omnidimensional Conflux</p>
            <p id="quick-start-tagline" class="text-sm text-amber-300 mt-1"></p>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div class="bg-gray-800 p-4 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-2 text-amber-400">Global Stats</h2>
                <p>Entropy Tokens: <span id="entropy-tokens-display" class="font-bold text-xl text-purple-400">0</span></p>
                <p class="mt-1">Reality Strain: <span id="reality-strain-display" class="font-bold text-xl text-red-400">0</span> / 100</p>
                <div class="stat-bar mt-2">
                    <div id="reality-strain-bar" class="stat-bar-fill"></div>
                </div>
                <button id="prestige-button" class="btn btn-primary mt-4 w-full font-arcade text-lg" disabled>Conflux Collapse!</button>
            </div>
            <div id="story-log-container" class="bg-gray-800 p-4 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-2 text-sky-400">Conflux Echoes (Story Log)</h2>
                <div id="story-log" class="story-log">
                    <p class="text-gray-500">The universe is quiet... for now.</p>
                </div>
            </div>
        </div>
        
        <div id="domains-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            </div>
    </div>

    <div id="target-overlay" class="target-overlay hidden">
        <p class="font-arcade text-2xl">SELECT TARGET DOMAIN</p>
    </div>

    <div id="lore-modal" class="modal-overlay hidden">
        <div class="modal-content-wrapper">
            <div class="modal-header">
                <h2 id="lore-modal-title" class="modal-title">Domain Lore</h2>
                <button id="close-lore-modal" class="modal-close-button">&times;</button>
            </div>
            <div id="lore-modal-content" class="modal-body modal-content-scroll">
                </div>
        </div>
    </div>

    <div id="how-to-play-modal" class="modal-overlay hidden">
        <div class="modal-content-wrapper">
            <div class="modal-header">
                <h2 class="modal-title">Welcome, Shaper!</h2>
                <button id="close-how-to-play-modal" class="modal-close-button">&times;</button>
            </div>
            <div class="modal-body">
                <p class="mb-3 text-lg">Here's the core of the Conflux:</p>
                <ul>
                    <li><strong>Gather Resources:</strong> Click on a Domain card (like Quantum Gardeners) to get its main resource.</li>
                    <li><strong>Automate:</strong> Spend those resources on Generators within a Domain to earn passively.</li>
                    <li><strong>Interact:</strong> Use Abilities to boost yourself or affect other Domains. Watch their cooldowns!</li>
                    <li><strong>Manage Strain:</strong> Actions increase Reality Strain (top bar).</li>
                    <li><strong>Prestige:</strong> When Reality Strain is full, use 'Conflux Collapse!' to earn Entropy Tokens for powerful permanent upgrades.</li>
                </ul>
                <p class="mt-4 text-center">The Conflux awaits your touch!</p>
                 <button id="got-it-how-to-play-modal" class="btn btn-primary w-full mt-6 font-arcade">Let's Go!</button>
            </div>
        </div>
    </div>
    
    <div id="help-modal" class="modal-overlay hidden">
        <div class="modal-content-wrapper">
            <div class="modal-header">
                <h2 class="modal-title">Conflux Guide</h2>
                <button id="close-help-modal" class="modal-close-button">&times;</button>
            </div>
            <div class="modal-body">
                <h3 class="text-xl font-semibold text-amber-300 mb-2">Quick Start:</h3>
                <ul>
                    <li>Click a Domain card to earn its primary resource.</li>
                    <li>Spend resources on Generators for passive income.</li>
                    <li>Use abilities to buff yourself or sabotage rivals.</li>
                    <li>Watch Reality Strain rise; when it maxes out, smash Conflux Collapse to earn Entropy Tokens.</li>
                    <li>Tokens grant permanent multipliers—repeat the cycle and see how far the multiverse stretches!</li>
                </ul>
                <p class="mt-4 text-sm text-gray-400">More detailed guides and domain specifics can be found by exploring and using the "View Lore" buttons on each domain card.</p>
            </div>
        </div>
    </div>

    <div id="coach-mark-overlay-container"></div>


    <script>
        // --- 1. EVENT BUS ---
        const Bus = (() => {
            const listeners = new Map();
            return {
                on: (t, fn) => (listeners.get(t) ?? listeners.set(t, new Set())).get(t).add(fn),
                off: (t, fn) => listeners.get(t)?.delete(fn),
                emit: (t, payload) => listeners.get(t)?.forEach(fn => {
                    try { fn(payload); } catch (e) { console.error(`Error in Bus listener for ${t}:`, e, payload); }
                })
            };
        })();

        // --- 2. CORE STATE CONTAINER ---
        const Game = {
            t: 0, lastUpdate: Date.now(), domains: {}, resources: {}, buffs: [],
            entropyTokens: 0, realityStrain: 0, maxRealityStrain: 100, prestigeCount: 0,
            activeTargeting: null,
            tutorialFlags: {}, // For in-session tutorial step tracking
            storyFlags: { // For multi-level lore and specific story event triggers
                // --- Flags for "cast ability X once EVER" ---
                gardeners_castCollapseCertaintyOnce: false,
                soundwaves_castDissonanceBurstOnce: false,
                soup_castBigSlurpOnce: false,
                afterlives_castAuditRivalOnce: false,
                fractals_castRecursiveSwarmOnce: false,
                snackbar_castParadoxSurgeOnce: false,
                emotions_castSerenityFieldOnce: false,
                // --- Flags for "achieve X with Y ability EVER" ---
                rivalsTargetedByAbilities: new Set(), // Stores domain IDs of rivals targeted by any ability
                afterlives_auditedRivals: new Set(), // Stores domain IDs of rivals audited by Bureaucratic Afterlives
                // --- Flags that reset on prestige ---
                soup_slurpsThisPrestige: 0,
                snackbar_surgesThisPrestige: 0,
            },

            addResource(id, amt = 0) {
                this.resources[id] = (this.resources[id] ?? 0) + amt;
                if (this.resources[id] < 0) this.resources[id] = 0; 
                Bus.emit('resource:update', { resourceId: id, amount: this.resources[id] });
            },
            getResource(id) { return this.resources[id] ?? 0; },
            increaseRealityStrain(amount) {
                this.realityStrain = Math.min(this.realityStrain + amount, this.maxRealityStrain);
                Bus.emit('realityStrain:update', { current: this.realityStrain, max: this.maxRealityStrain });
            }
        };

        // --- 3. FACTORY HELPERS ---
        function defineDomain(cfg) {
            Game.domains[cfg.id] = {
                ...cfg, level: 0,
                generators: (cfg.generators || []).map(g => ({ ...g, level: 0, currentCost: { ...g.baseCost } })),
                abilities: (cfg.abilities || []).map(a => ({ ...a, nextUse: 0 })),
                isTargetable: false,
                allLoreTexts: cfg.allLoreTexts || [], // Array of 10 lore strings
                unlockedLoreLevel: 0 // Highest lore level unlocked for this domain
            };
            // Ensure current `lore` property from cfg is not directly used if `allLoreTexts` is primary
            // delete Game.domains[cfg.id].lore; // Or handle its transition carefully

            Game.addResource(cfg.clickResource.id, 0);
            (cfg.generators || []).forEach(gen => Object.keys(gen.baseCost).forEach(resId => Game.addResource(resId, 0)));
            (cfg.abilities || []).forEach(ab => { if(ab.cost) Object.keys(ab.cost).forEach(resId => Game.addResource(resId, 0)); });
        }

        // --- 4. CORE GAME ACTIONS (clickDomain, buyGenerator, castAbility, tick) ---
        // These functions remain largely the same as in the previous version,
        // with minor adjustments for tutorial integration or clarity if needed.
        // For brevity, I'll only show changes or key parts.
        function clickDomain(domainId) {
            const domain = Game.domains[domainId];
            if (!domain) return;
            let clickMultiplier = 1;
            Game.buffs.forEach(buff => {
                if (buff.affects === 'click' && (!buff.domainId || buff.domainId === domainId)) {
                    clickMultiplier *= (buff.multiplier || 1);
                }
            });
            const gain = domain.clickResource.baseAmount * clickMultiplier * (1 + Game.entropyTokens * 0.005);
            Game.addResource(domain.clickResource.id, gain);
            Game.increaseRealityStrain(0.01 * (Game.prestigeCount + 1)); 
            
            // Tutorial Hook
            if (domainId === 'gardeners' && !Game.tutorialFlags.clickedFirstDomain) {
                 TutorialManager.advanceStepIfCurrent('clickFirstDomain');
            }
        }

        function buyGenerator(domainId, generatorId) {
            const domain = Game.domains[domainId];
            const gen = domain.generators.find(g => g.id === generatorId);
            if (!domain || !gen) return;
            const finalCost = {...gen.currentCost};
            if (gen.costMultiplier && gen.costMultiplier > 1) {
                for (const resId in finalCost) { finalCost[resId] = Math.floor(finalCost[resId] * gen.costMultiplier); }
            }

            if (payCost(finalCost)) {
                gen.level++;
                Object.keys(gen.baseCost).forEach(resId => {
                    gen.currentCost[resId] = Math.floor(gen.baseCost[resId] * Math.pow(gen.costScaling, gen.level));
                });
                Game.increaseRealityStrain(0.1 * gen.level * (Game.prestigeCount + 1)); 
                Bus.emit('generator:bought', { domainId, generatorId, newLevel: gen.level, newCost: gen.currentCost });

                // Tutorial Hook
                if (domainId === 'gardeners' && generatorId === 'timelineBloomer' && !Game.tutorialFlags.boughtFirstGenerator) {
                    TutorialManager.advanceStepIfCurrent('buyFirstGenerator');
                }
            } else {
                Bus.emit('feedback:message', { message: "Not enough resources!", type: 'error' });
            }
        }
        
        function castAbility(casterDomainId, abilityId, targetDomainId = null) {
            // ... (existing castAbility logic)
            // No direct tutorial hooks here for now, but could be added
            const casterDomain = Game.domains[casterDomainId];
            const ability = casterDomain.abilities.find(a => a.id === abilityId);

            if (!casterDomain || !ability) return;
            if (Game.t < ability.nextUse) {
                 Bus.emit('feedback:message', { message: "Ability on cooldown!", type: 'warning' });
                return;
            }
            if (ability.requiresTarget && !targetDomainId) {
                Game.activeTargeting = { casterId: casterDomainId, abilityId: abilityId, ability: ability };
                Bus.emit('ability:targeting_started', {casterDomainId, abilityId});
                return;
            }

            if (payCost(ability.cost)) {
                const targetDomain = targetDomainId ? Game.domains[targetDomainId] : null;
                try { ability.effect(casterDomain, targetDomain); }
                catch (e) { console.error("Error executing ability effect:", ability.id, e); Bus.emit('feedback:message', { message: `Error with ability ${ability.name}.`, type: 'error' }); return; }
                ability.nextUse = Game.t + ability.cooldownMs;
                Game.increaseRealityStrain( (ability.strainFactor || 1) * (Game.prestigeCount + 1));
                Bus.emit('ability:cast', { casterDomainId, abilityId, targetDomainId, nextUse: ability.nextUse });

                // --- Story Flag Updates on Ability Cast ---
                if (targetDomainId && targetDomainId !== casterDomainId) {
                    Game.storyFlags.rivalsTargetedByAbilities.add(targetDomainId);
                }
                if (casterDomainId === 'gardeners' && abilityId === 'collapseCertainty') Game.storyFlags.gardeners_castCollapseCertaintyOnce = true;
                if (casterDomainId === 'soundwaves' && abilityId === 'dissonanceBurst') Game.storyFlags.soundwaves_castDissonanceBurstOnce = true;
                if (casterDomainId === 'soup' && abilityId === 'bigSlurp') {
                    Game.storyFlags.soup_castBigSlurpOnce = true;
                    Game.storyFlags.soup_slurpsThisPrestige = (Game.storyFlags.soup_slurpsThisPrestige || 0) + 1;
                }
                if (casterDomainId === 'afterlives' && abilityId === 'auditRival') {
                    Game.storyFlags.afterlives_castAuditRivalOnce = true;
                    if (targetDomainId) Game.storyFlags.afterlives_auditedRivals.add(targetDomainId);
                }
                if (casterDomainId === 'fractals' && abilityId === 'recursiveSwarm') Game.storyFlags.fractals_castRecursiveSwarmOnce = true;
                if (casterDomainId === 'snackbar' && abilityId === 'paradoxSurge') {
                    Game.storyFlags.snackbar_castParadoxSurgeOnce = true;
                    Game.storyFlags.snackbar_surgesThisPrestige = (Game.storyFlags.snackbar_surgesThisPrestige || 0) + 1;
                }
                if (casterDomainId === 'emotions' && abilityId === 'serenityField') Game.storyFlags.emotions_castSerenityFieldOnce = true;
                // --- End Story Flag Updates ---

                if(Game.activeTargeting) Bus.emit('ability:targeting_ended');
                Game.activeTargeting = null;
                 // Tutorial Hook for first ability cast
                if (!Game.tutorialFlags.castFirstAbility) {
                    TutorialManager.advanceStepIfCurrent('castFirstAbility');
                }
            } else {
                Bus.emit('feedback:message', { message: "Not enough resources for ability!", type: 'error' });
                if(Game.activeTargeting) Bus.emit('ability:targeting_ended');
                Game.activeTargeting = null;
            }
        }

        function tick(dtMs) {
            Game.t += dtMs;
            // ... (existing passive generation logic) ...
             Object.values(Game.domains).forEach(d => {
                let domainProductionMultiplier = 1 * getGlobalProductionMultiplier();
                Game.buffs.forEach(buff => {
                    if (buff.affects === 'production' && buff.domainId === d.id) {
                        domainProductionMultiplier *= (buff.multiplier || 1);
                    }
                });
                d.generators.forEach(g => {
                    if (g.level > 0) {
                        let baseGenProd = (typeof g.baseProd === 'number') ? g.baseProd : (g.baseProd[d.clickResource.id] || 0);
                        const gain = baseGenProd * g.level * Math.pow(g.prodScaling, g.level -1) * domainProductionMultiplier * (dtMs / 1000);
                        Game.addResource(d.clickResource.id, gain);
                    }
                });
            });
            // ... (existing buff expiry logic) ...
            const activeBuffs = [];
            Game.buffs.forEach(buff => {
                if (Game.t < buff.until) {
                    activeBuffs.push(buff);
                    if (buff.onTick) buff.onTick(Game, buff.domainId);
                } else {
                    if (buff.onEnd) buff.onEnd(Game, buff.domainId); 
                    Bus.emit('buff:expired', { buffId: buff.id, domainId: buff.domainId });
                }
            });
            Game.buffs = activeBuffs;

            Bus.emit('tick', dtMs); 
            TutorialManager.checkState(); // Check tutorial state every tick
        }
        
        // --- 5. UTILS (getGlobalProductionMultiplier, payCost, addBuff) ---
        // Largely unchanged
        function getGlobalProductionMultiplier() {
            let mult = 1;
            Game.buffs.forEach(b => { if (b.affects === 'global_production' && (!b.domainId)) mult *= (b.multiplier || 1); });
            mult *= (1 + (Game.entropyTokens * 0.01)); 
            return mult;
        }
        function payCost(costObj) {
            if (!costObj) return true; 
            for (const resId in costObj) { if (Game.getResource(resId) < costObj[resId]) return false; }
            for (const resId in costObj) { Game.addResource(resId, -costObj[resId]); }
            return true;
        }
        function addBuff(buffConfig) {
            const newBuff = { ...buffConfig, startTime: Game.t, until: Game.t + buffConfig.durationMs };
            if (newBuff.replacesExisting) { Game.buffs = Game.buffs.filter(b => !(b.id.startsWith(newBuff.id.split('_')[0]) && b.domainId === newBuff.domainId));}
            Game.buffs.push(newBuff);
            if (newBuff.onApply) newBuff.onApply(Game, newBuff.domainId);
            Bus.emit('buff:added', newBuff);
        }
        
        // --- 6. STORY ENGINE (addStoryEvent, checkStoryEvents) ---
        // Largely unchanged, but new tutorial hints will be added via addStoryEvent
        const storyEvents = []; 
        let storyLogInitialized = false;
        function addStoryEvent(id, triggerFn, message, oneTime = true, onFireAction = null) {
            storyEvents.push({ id, trigger: triggerFn, message, action: onFireAction, fired: false, oneTime });
        }
        function checkStoryEvents() {
            storyEvents.forEach(ev => {
                if ((!ev.fired || !ev.oneTime) && ev.trigger(Game)) {
                    if (ev.oneTime) ev.fired = true;
                    const storyLog = document.getElementById('story-log');
                    if (!storyLogInitialized && storyLog) { storyLog.innerHTML = ''; storyLogInitialized = true; }
                    const entry = document.createElement('p');
                    entry.className = 'story-log-entry text-teal-300';
                    entry.innerHTML = `📜 ${ev.message}`; 
                    if (storyLog) {
                        if (storyLog.firstChild) storyLog.insertBefore(entry, storyLog.firstChild);
                        else storyLog.appendChild(entry);
                        while (storyLog.children.length > 20) storyLog.removeChild(storyLog.lastChild);
                    }
                    if (ev.action) ev.action(Game); 
                    Bus.emit('story:fired', { eventId: ev.id, message: ev.message });
                }
            });
        }

        // --- PRESTIGE ---
        // Largely unchanged
        function attemptPrestige() {
            if (Game.realityStrain >= Game.maxRealityStrain) {
                const tokensEarned = Math.floor(1 + Game.prestigeCount * 0.5 + Object.values(Game.domains).reduce((sum, d) => sum + d.generators.reduce((s,g) => s + g.level, 0), 0) / 20); 
                Game.entropyTokens += tokensEarned; Game.prestigeCount++; Game.resources = {}; 
                Object.values(Game.domains).forEach(d => {
                    d.level = 0; d.generators.forEach(g => { g.level = 0; g.currentCost = { ...g.baseCost }; delete g.costMultiplier; });
                    d.abilities.forEach(a => a.nextUse = 0); Game.addResource(d.clickResource.id, 0);
                    // d.unlockedLoreLevel remains, as lore unlocks are persistent across prestiges.
                });
                Game.buffs = []; Game.realityStrain = 0; Game.tutorialFlags = {}; // Reset in-session tutorial flags
                
                // Reset cycle-specific story flags
                Game.storyFlags.soup_slurpsThisPrestige = 0;
                Game.storyFlags.snackbar_surgesThisPrestige = 0;
                // Persistent story flags (like castOnce, rivalsTargetedByAbilities, auditedRivals) are NOT reset here.

                storyEvents.forEach(ev => { 
                    // For lore events, they are typically oneTime. If any non-lore story events are repeatable per prestige:
                    if(!ev.oneTime && !ev.id.includes('_lore_lvl')) ev.fired = false; 
                }); 
                storyLogInitialized = false;
                const storyLog = document.getElementById('story-log'); if(storyLog) storyLog.innerHTML = '<p class="text-gray-500">A new cycle begins...</p>';
                Bus.emit('game:prestiged', { tokensEarned, totalTokens: Game.entropyTokens });
                Bus.emit('feedback:message', { message: `Conflux Collapsed! Earned ${tokensEarned} Entropy Tokens.`, type: 'success', fontClass: 'font-arcade text-xl' });
                renderAllDomains(); updateGlobalStatsUI();
                TutorialManager.resetForNewSession(); // Reset tutorial for next prestige if not fully completed globally
                TutorialManager.checkState(); // Check if tutorial needs to restart
            } else { Bus.emit('feedback:message', { message: "Reality is not strained enough to collapse!", type: 'warning' }); }
        }

        // --- TUTORIAL MANAGER ---
        const TutorialManager = (() => {
            const tutorialSteps = [
                {
                    id: 'clickFirstDomain',
                    trigger: (game) => game.t > 1500 && !game.tutorialFlags.clickedFirstDomain,
                    selector: '#click-gardeners',
                    message: 'Welcome, Shaper! Click here on "Quantum Gardeners" to gather your first Probability Petals.',
                    onComplete: (game) => game.tutorialFlags.clickedFirstDomain = true,
                    position: 'bottom' 
                },
                {
                    id: 'buyFirstGenerator',
                    trigger: (game) => game.tutorialFlags.clickedFirstDomain && game.getResource('probabilityPetal') >= 10 && (!game.domains.gardeners?.generators.find(g=>g.id==='timelineBloomer')?.level) && !game.tutorialFlags.boughtFirstGenerator,
                    selector: '#buy-gen-gardeners-timelineBloomer',
                    message: 'Great! Now spend 10 Petals to buy a "Timeline Bloomer". It generates Petals for you automatically!',
                    onComplete: (game) => game.tutorialFlags.boughtFirstGenerator = true,
                    position: 'bottom'
                },
                {
                    id: 'castFirstAbility',
                    trigger: (game) => game.tutorialFlags.boughtFirstGenerator && game.getResource('probabilityPetal') >= Game.domains.gardeners?.abilities.find(a=>a.id==='collapseCertainty')?.cost?.probabilityPetal && !game.tutorialFlags.castFirstAbility,
                    selector: '#cast-ab-gardeners-collapseCertainty',
                    message: 'Abilities can give you an edge. When you have enough Petals, try casting "Collapse Certainty". (It needs a target!)',
                    onComplete: (game) => game.tutorialFlags.castFirstAbility = true,
                    position: 'top'
                },
                {
                    id: 'prestigeHint',
                    trigger: (game) => game.realityStrain >= Game.maxRealityStrain * 0.3 && game.prestigeCount === 0 && !game.tutorialFlags.sawPrestigeHint, // Show hint earlier
                    selector: '#prestige-button',
                    message: 'See "Reality Strain" (top bar)? When it\'s full, "Conflux Collapse!" becomes active. This resets progress but gives powerful Entropy Tokens!',
                    onComplete: (game) => game.tutorialFlags.sawPrestigeHint = true,
                    position: 'top'
                }
            ];
            let currentStepIndex = 0;
            let activeCoachMarkElements = null;
            const coachMarkContainer = document.getElementById('coach-mark-overlay-container');

            function displayStep(step) {
                if (activeCoachMarkElements || !coachMarkContainer) return; // Already showing or no container

                const targetElement = document.querySelector(step.selector);
                if (!targetElement) {
                    console.warn(`Tutorial: Target element not found for selector: ${step.selector}`);
                    // Potentially advance to next step or wait
                    return;
                }
                
                coachMarkContainer.innerHTML = ''; // Clear previous

                // Create message box
                const messageBox = document.createElement('div');
                messageBox.className = 'coach-mark-message-box';
                messageBox.innerHTML = `<p class="mb-3 text-sm">${step.message}</p><button id="coach-got-it" class="btn btn-primary btn-sm w-full">Got it!</button>`;
                
                // Position message box (simple logic, can be improved)
                const targetRect = targetElement.getBoundingClientRect();
                if (step.position === 'top') {
                    messageBox.style.bottom = `${window.innerHeight - targetRect.top + 10}px`;
                } else { // Default bottom
                    messageBox.style.top = `${targetRect.bottom + 10}px`;
                }
                messageBox.style.left = `${targetRect.left + (targetRect.width / 2) - (messageBox.offsetWidth / 2)}px`;
                 // Ensure it's within viewport horizontally
                if (targetRect.left + (targetRect.width / 2) - (messageBox.offsetWidth / 2) < 0) {
                    messageBox.style.left = '10px';
                } else if (targetRect.left + (targetRect.width / 2) + (messageBox.offsetWidth / 2) > window.innerWidth) {
                    messageBox.style.left = `${window.innerWidth - messageBox.offsetWidth - 10}px`;
                }


                coachMarkContainer.appendChild(messageBox);
                targetElement.classList.add('coach-mark-highlight', 'coach-mark-highlight-pulsate');
                
                activeCoachMarkElements = { targetElement, messageBox };

                document.getElementById('coach-got-it').addEventListener('click', () => {
                    advanceStepIfCurrent(step.id);
                });
            }

            function clearCurrentStepDisplay() {
                if (activeCoachMarkElements) {
                    activeCoachMarkElements.targetElement.classList.remove('coach-mark-highlight', 'coach-mark-highlight-pulsate');
                    if (activeCoachMarkElements.messageBox.parentNode) {
                         activeCoachMarkElements.messageBox.parentNode.removeChild(activeCoachMarkElements.messageBox);
                    }
                }
                if(coachMarkContainer) coachMarkContainer.innerHTML = ''; // Clear container fully
                activeCoachMarkElements = null;
            }
            
            function advanceStepIfCurrent(completedStepId) {
                if (currentStepIndex < tutorialSteps.length && tutorialSteps[currentStepIndex].id === completedStepId) {
                    const step = tutorialSteps[currentStepIndex];
                    if (step.onComplete) step.onComplete(Game);
                    
                    clearCurrentStepDisplay();
                    currentStepIndex++;
                    checkState(); // Check for the next step immediately
                }
            }

            function checkState() {
                if (localStorage.getItem('tutorialFullyCompleted_v1')) return;
                if (currentStepIndex >= tutorialSteps.length) {
                    localStorage.setItem('tutorialFullyCompleted_v1', 'true');
                    Bus.emit('feedback:message', { message: 'Guided tour complete! The Conflux is yours to shape.', type: 'success', fontClass: 'font-arcade' });
                    clearCurrentStepDisplay(); // Ensure last coach mark is cleared
                    return;
                }
                const nextStep = tutorialSteps[currentStepIndex];
                if (nextStep && nextStep.trigger(Game)) {
                    displayStep(nextStep);
                } else if (activeCoachMarkElements && nextStep && !nextStep.trigger(Game)) {
                    // If the trigger for the current coach mark becomes false (e.g. player did something else)
                    // clearCurrentStepDisplay(); // Optionally hide if condition no longer met
                }
            }
            
            function resetForNewSession() {
                // This resets the tutorial if it wasn't fully completed globally.
                // For a "per prestige" tutorial, you'd clear tutorialFlags and reset currentStepIndex.
                if (!localStorage.getItem('tutorialFullyCompleted_v1')) {
                    currentStepIndex = 0;
                    Game.tutorialFlags = {}; // Reset in-session flags
                    clearCurrentStepDisplay();
                }
            }

            return { checkState, advanceStepIfCurrent, resetForNewSession };
        })();


        // --- UI RENDERING AND UPDATES ---
        // (formatNumber, renderDomainCard, updateDomainUICard, renderAllDomains, updateGlobalStatsUI)
        // Largely unchanged, ensure IDs used by tutorial selectors are correct.
        const domainsContainer = document.getElementById('domains-container');
        const entropyTokensDisplay = document.getElementById('entropy-tokens-display');
        const realityStrainDisplay = document.getElementById('reality-strain-display');
        const realityStrainBar = document.getElementById('reality-strain-bar');
        const prestigeButton = document.getElementById('prestige-button');
        const targetOverlay = document.getElementById('target-overlay');
        const quickStartTagline = document.getElementById('quick-start-tagline');

        function formatNumber(num) {
            if (num === undefined || num === null) return '0.00';
            if (Math.abs(num) < 0.0001 && num !==0) return num.toExponential(2);
            if (Math.abs(num) < 1000) return num.toFixed(2);
            const s = ["", "k", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"];
            const i = Math.floor(Math.log10(Math.abs(num)) / 3);
            if (i >= s.length) return num.toExponential(2);
            return (num / Math.pow(1000, i)).toFixed(2) + s[i];
        }
        
        function renderDomainCard(domain) {
            const card = document.createElement('div');
            card.id = `domain-${domain.id}`;
            card.className = 'domain-card flex flex-col space-y-3';
            card.style.borderColor = domain.color || '#374151';

            let generatorsHTML = domain.generators.map(gen => {
                const effectiveCost = {...gen.currentCost};
                if (gen.costMultiplier && gen.costMultiplier > 1) {
                    for (const resId in effectiveCost) effectiveCost[resId] = Math.floor(effectiveCost[resId] * gen.costMultiplier);
                }
                const costString = Object.entries(effectiveCost).map(([resId, amount]) => `${formatNumber(amount)} ${Game.resources_map?.[resId]?.name || resId}`).join(', ');
                const genProd = typeof gen.baseProd === 'number' ? gen.baseProd : (gen.baseProd[domain.clickResource.id] || 0);
                const currentProd = gen.level > 0 ? genProd * gen.level * Math.pow(gen.prodScaling, gen.level -1) * getGlobalProductionMultiplier() : 0;
                return `
                    <div class="p-2 bg-gray-700 rounded">
                        <div class="flex justify-between items-center">
                            <h4 class="font-semibold text-sm tooltip">${gen.name} (Lvl ${gen.level})
                                <span class="tooltiptext">${gen.description || 'Generates resources passively.'}<br>Base Prod: ${formatNumber(genProd * gen.level * Math.pow(gen.prodScaling, gen.level -1))}/s<br>Actual Prod: ${formatNumber(currentProd)}/s</span>
                            </h4>
                            <button id="buy-gen-${domain.id}-${gen.id}" class="btn btn-secondary btn-sm text-xs">Buy (${costString})</button>
                        </div>
                        <p class="text-xs text-gray-400">Produces: ${formatNumber(currentProd)} ${domain.clickResource.name}/s</p>
                    </div>`;
            }).join('');

            let abilitiesHTML = domain.abilities.map(ab => {
                const costString = ab.cost ? Object.entries(ab.cost).map(([resId, amount]) => `${formatNumber(amount)} ${Game.resources_map?.[resId]?.name || resId}`).join(', ') : "No Cost";
                return `
                    <div class="p-2 bg-gray-700 rounded">
                        <div class="flex justify-between items-center">
                             <h4 class="font-semibold text-sm tooltip">${ab.name}
                                <span class="tooltiptext">${ab.description || 'A special ability.'}<br>CD: ${ab.cooldownMs/1000}s. Cost: ${costString}<br>Strain: ${ab.strainFactor || 1}</span>
                            </h4>
                            <button id="cast-ab-${domain.id}-${ab.id}" class="btn btn-secondary btn-sm text-xs ${ab.type === 'aggressive' ? 'bg-red-700 hover:bg-red-600' : (ab.type === 'defensive' ? 'bg-sky-700 hover:bg-sky-600' : (ab.type === 'utility' ? 'bg-yellow-600 hover:bg-yellow-500' : '')) }">Cast</button>
                        </div>
                        <div class="text-xs text-gray-400">Cooldown: <span id="cd-${domain.id}-${ab.id}">${(ab.nextUse > Game.t ? (ab.nextUse - Game.t)/1000 : 0).toFixed(1)}s</span></div>
                    </div>`;
            }).join('');

            card.innerHTML = `
                <div class="flex justify-between items-start">
                    <h3 class="text-xl font-bold font-arcade" style="color: ${domain.color || '#FFF'}">${domain.name}</h3>
                    <div class="text-xs text-gray-400 tooltip">Lvl ${domain.level}<span class="tooltiptext">${domain.description || 'A unique domain.'}</span></div>
                </div>
                <button id="click-${domain.id}" class="btn btn-primary w-full py-3 font-arcade text-lg">Gather ${domain.clickResource.name}</button>
                <p class="text-center resource-display">${domain.clickResource.name}: <span id="res-${domain.clickResource.id}" class="font-bold text-lg">${formatNumber(Game.getResource(domain.clickResource.id))}</span></p>
                ${generatorsHTML ? `<div class="space-y-2"><h5>Generators:</h5>${generatorsHTML}</div>` : ''}
                ${abilitiesHTML ? `<div class="space-y-2"><h5>Abilities:</h5>${abilitiesHTML}</div>` : ''}
                <button id="lore-${domain.id}" class="btn btn-secondary btn-sm text-xs mt-1 w-full bg-purple-700 hover:bg-purple-600">View Lore</button>`;
            
            domainsContainer.appendChild(card);

            document.getElementById(`click-${domain.id}`).addEventListener('click', (event) => {
                clickDomain(domain.id); // Game logic
                const rect = event.target.getBoundingClientRect();
                const x = event.clientX - rect.left; const y = event.clientY - rect.top;
                let clickGain = domain.clickResource.baseAmount * (1 + Game.entropyTokens * 0.005);
                Game.buffs.forEach(buff => { if (buff.affects === 'click' && (!buff.domainId || buff.domainId === domain.id)) clickGain *= (buff.multiplier || 1); });
                Bus.emit('feedback:click_visual', { element: event.target, x, y, text: `+${formatNumber(clickGain)}` });
            });
            domain.generators.forEach(gen => { const btn = document.getElementById(`buy-gen-${domain.id}-${gen.id}`); if (btn) btn.addEventListener('click', () => buyGenerator(domain.id, gen.id)); });
            domain.abilities.forEach(ab => { const btn = document.getElementById(`cast-ab-${domain.id}-${ab.id}`); if (btn) btn.addEventListener('click', () => castAbility(domain.id, ab.id)); });
            const loreButton = document.getElementById(`lore-${domain.id}`); if (loreButton) loreButton.addEventListener('click', () => showLoreModal(domain.id));
            card.addEventListener('click', () => { if (Game.activeTargeting && Game.activeTargeting.casterId !== domain.id) castAbility(Game.activeTargeting.casterId, Game.activeTargeting.abilityId, domain.id); });
        }

        function updateDomainUICard(domainId) {
            // ... (This function is complex and mostly unchanged, ensure selectors are accurate for tutorial)
            // Key is to ensure buttons are correctly enabled/disabled for tutorial triggers.
            const domain = Game.domains[domainId]; if (!domain) return;
            const card = document.getElementById(`domain-${domainId}`); if (!card) return; 
            const resDisplay = document.getElementById(`res-${domain.clickResource.id}`); if (resDisplay) resDisplay.textContent = formatNumber(Game.getResource(domain.clickResource.id));
            const levelDisplay = card.querySelector('.text-xs.text-gray-400.tooltip'); if(levelDisplay) levelDisplay.childNodes[0].nodeValue = `Lvl ${domain.level}`;
            domain.generators.forEach(gen => {
                const genLvlDisplay = card.querySelector(`#buy-gen-${domain.id}-${gen.id}`)?.previousElementSibling?.childNodes[0]; if(genLvlDisplay) genLvlDisplay.nodeValue = `${gen.name} (Lvl ${gen.level}) `;
                const effectiveCost = {...gen.currentCost}; if (gen.costMultiplier && gen.costMultiplier > 1) { for (const resId in effectiveCost) effectiveCost[resId] = Math.floor(effectiveCost[resId] * gen.costMultiplier); }
                const costString = Object.entries(effectiveCost).map(([resId, amount]) => `${formatNumber(amount)} ${Game.resources_map?.[resId]?.name || resId}`).join(', ');
                const buyBtn = document.getElementById(`buy-gen-${domain.id}-${gen.id}`); 
                if (buyBtn) {
                    buyBtn.textContent = `Buy (${costString})`; let canAfford = true;
                    for (const resId in effectiveCost) { if (Game.getResource(resId) < effectiveCost[resId]) { canAfford = false; break; }}
                    buyBtn.disabled = !canAfford; buyBtn.classList.toggle('btn-disabled', !canAfford);
                    if (canAfford) buyBtn.classList.remove('btn-disabled'); else buyBtn.classList.add('btn-disabled');
                }
                const genProd = typeof gen.baseProd === 'number' ? gen.baseProd : (gen.baseProd[domain.clickResource.id] || 0);
                const currentProd = gen.level > 0 ? genProd * gen.level * Math.pow(gen.prodScaling, gen.level -1) * getGlobalProductionMultiplier() : 0;
                const genTooltip = card.querySelector(`#buy-gen-${domain.id}-${gen.id}`)?.previousElementSibling?.querySelector('.tooltiptext');
                if (genTooltip) genTooltip.innerHTML = `${gen.description || 'Generates resources passively.'}<br>Base Prod: ${formatNumber(genProd * gen.level * Math.pow(gen.prodScaling, gen.level -1))}/s<br>Actual Prod: ${formatNumber(currentProd)}/s`;
                const prodDisplay = card.querySelector(`#buy-gen-${domain.id}-${gen.id}`)?.parentElement?.nextElementSibling; if(prodDisplay) prodDisplay.textContent = `Produces: ${formatNumber(currentProd)} ${domain.clickResource.name}/s`;
            });
            domain.abilities.forEach(ab => {
                const cdDisplay = document.getElementById(`cd-${domain.id}-${ab.id}`); const timeLeft = ab.nextUse > Game.t ? (ab.nextUse - Game.t) / 1000 : 0; if (cdDisplay) cdDisplay.textContent = timeLeft.toFixed(1) + 's';
                const castBtn = document.getElementById(`cast-ab-${domain.id}-${ab.id}`);
                if (castBtn) {
                    let canAfford = true; if (ab.cost) { for (const resId in ab.cost) { if (Game.getResource(resId) < ab.cost[resId]) { canAfford = false; break; }}}
                    castBtn.disabled = timeLeft > 0 || !canAfford; castBtn.classList.toggle('btn-disabled', timeLeft > 0 || !canAfford);
                    // Manage specific button styling if not disabled
                    if (!(timeLeft > 0 || !canAfford)) {
                        castBtn.classList.remove('btn-disabled');
                        castBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600'); // remove base secondary
                        if (ab.type === 'aggressive') castBtn.classList.add('bg-red-700', 'hover:bg-red-600');
                        else if (ab.type === 'defensive') castBtn.classList.add('bg-sky-700', 'hover:bg-sky-600');
                        else if (ab.type === 'utility') castBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-500');
                        else castBtn.classList.add('bg-gray-700', 'hover:bg-gray-600'); // default if no specific type
                    } else { // Is disabled
                        castBtn.classList.add('btn-disabled');
                         // Remove specific type styling when disabled
                        castBtn.classList.remove('bg-red-700', 'hover:bg-red-600', 'bg-sky-700', 'hover:bg-sky-600', 'bg-yellow-600', 'hover:bg-yellow-500');
                    }
                }
            });
        }
        function renderAllDomains() { domainsContainer.innerHTML = ''; Object.values(Game.domains).forEach(renderDomainCard); }
        function updateGlobalStatsUI() {
            if (entropyTokensDisplay) entropyTokensDisplay.textContent = formatNumber(Game.entropyTokens);
            if (realityStrainDisplay) realityStrainDisplay.textContent = `${Game.realityStrain.toFixed(2)} / ${Game.maxRealityStrain}`;
            if (realityStrainBar) realityStrainBar.style.width = `${(Game.realityStrain / Game.maxRealityStrain) * 100}%`;
            if (prestigeButton) {
                prestigeButton.disabled = Game.realityStrain < Game.maxRealityStrain;
                prestigeButton.classList.toggle('btn-disabled', Game.realityStrain < Game.maxRealityStrain);
                prestigeButton.classList.toggle('animate-pulse', Game.realityStrain >= Game.maxRealityStrain);
                if (Game.realityStrain >= Game.maxRealityStrain) { prestigeButton.classList.remove('bg-indigo-600', 'hover:bg-indigo-700'); prestigeButton.classList.add('bg-red-500', 'hover:bg-red-600'); } 
                else { prestigeButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700'); prestigeButton.classList.remove('bg-red-500', 'hover:bg-red-600'); }
            }
        }

        // --- EVENT LISTENERS FOR UI ---
        // (Bus.on resource:update, generator:bought, ability:cast, buff:added/expired, tick, realityStrain:update, game:prestiged, ability:targeting_started/ended, feedback:message, feedback:click_visual)
        // These are mostly unchanged but crucial for UI reactivity.
        Bus.on('resource:update', () => Object.values(Game.domains).forEach(d => updateDomainUICard(d.id)));
        Bus.on('generator:bought', (p) => { Game.domains[p.domainId].level = Game.domains[p.domainId].generators.reduce((s, gen) => s + gen.level, 0); updateDomainUICard(p.domainId); });
        Bus.on('ability:cast', (p) => { updateDomainUICard(p.casterDomainId); if (p.targetDomainId) updateDomainUICard(p.targetDomainId); });
        Bus.on('buff:added', (b) => { if (b.domainId) updateDomainUICard(b.domainId); else Object.values(Game.domains).forEach(d => updateDomainUICard(d.id)); });
        Bus.on('buff:expired', (b) => { if (b.domainId) updateDomainUICard(b.domainId); else Object.values(Game.domains).forEach(d => updateDomainUICard(d.id)); });
        Bus.on('tick', () => Object.values(Game.domains).forEach(d => updateDomainUICard(d.id)));
        Bus.on('realityStrain:update', updateGlobalStatsUI); Bus.on('game:prestiged', updateGlobalStatsUI);
        Bus.on('ability:targeting_started', ({casterDomainId}) => {
            targetOverlay.classList.remove('hidden');
            Object.values(Game.domains).forEach(d => { const card = document.getElementById(`domain-${d.id}`); if (card) { if (d.id !== casterDomainId) card.classList.add('targetable', 'opacity-75', 'hover:opacity-100'); else card.classList.add('opacity-50'); }});
        });
        Bus.on('ability:targeting_ended', () => {
            targetOverlay.classList.add('hidden');
            Object.values(Game.domains).forEach(d => { const card = document.getElementById(`domain-${d.id}`); if (card) card.classList.remove('targetable', 'opacity-75', 'hover:opacity-100', 'opacity-50'); });
        });
        Bus.on('feedback:message', (payload) => { /* ... existing feedback message logic ... */ 
            const { message, type = 'info', fontClass } = payload; const area = document.getElementById('story-log'); if (!area) return;
            const entry = document.createElement('p'); let color = 'text-gray-300';
            if (type === 'success') color = 'text-green-400'; else if (type === 'warning') color = 'text-yellow-400'; else if (type === 'error') color = 'text-red-400';
            entry.className = `story-log-entry italic ${color} ${fontClass || ''}`; entry.textContent = `📢 ${message}`;
            if (area.firstChild) area.insertBefore(entry, area.firstChild); else area.appendChild(entry);
            setTimeout(() => { if(entry.parentNode) entry.parentNode.removeChild(entry);}, 5000);
        });
        Bus.on('feedback:click_visual', ({ element, x, y, text }) => { /* ... existing click visual logic ... */
            const fb = document.createElement('div'); fb.textContent = text; fb.className = 'absolute font-bold text-lg pointer-events-none';
            const dId = element.id.split('-')[1]; fb.style.color = Game.domains[dId]?.color || '#FFF'; 
            fb.style.left = `${x - 15}px`; fb.style.top = `${y - 20}px`;
            fb.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out'; fb.style.transform = 'translateY(0px)'; fb.style.opacity = '1';
            const pTarget = element.tagName === 'BUTTON' ? element.parentElement : element; pTarget.appendChild(fb);
            requestAnimationFrame(() => { fb.style.transform = 'translateY(-30px)'; fb.style.opacity = '0'; });
            setTimeout(() => { if (fb.parentNode) fb.parentNode.removeChild(fb); }, 500);
        });

        // --- LORE MODAL ---
        // Unchanged
        const loreModal = document.getElementById('lore-modal');
        const loreModalTitle = document.getElementById('lore-modal-title');
        const loreModalContent = document.getElementById('lore-modal-content');
        const closeLoreModalButton = document.getElementById('close-lore-modal');

        function showLoreModal(domainId) {
            const domain = Game.domains[domainId];
            if (!domain) {
                console.warn("Lore modal: Domain not found", domainId);
                return;
            }

            loreModalTitle.textContent = `${domain.name} - Lore`;
            let contentHTML = '';

            if (!domain.allLoreTexts || domain.allLoreTexts.length === 0) {
                contentHTML = "<p>No lore entries defined for this domain.</p>";
            } else if (domain.unlockedLoreLevel === 0) {
                contentHTML = `<p class="text-gray-400 italic">No lore unlocked yet for ${domain.name}. Keep playing to uncover its secrets!</p>`;
            } else {
                for (let i = 0; i < domain.unlockedLoreLevel; i++) {
                    if (domain.allLoreTexts[i]) {
                        contentHTML += `<div class="mb-4 pb-2 border-b border-gray-700 last:border-b-0">`;
                        contentHTML += `<h4 class="text-lg font-semibold text-amber-300 mb-1">Level ${i + 1}</h4>`;
                        // Simple paragraph splitting for potentially longer lore entries, or just display as is.
                        // Assuming each lore entry is a single block of text for now.
                        contentHTML += `<p class="text-base text-gray-300">${domain.allLoreTexts[i]}</p>`;
                        contentHTML += `</div>`;
                    }
                }
                 if (domain.unlockedLoreLevel < domain.allLoreTexts.length) {
                    contentHTML += `<p class="mt-4 text-gray-500 italic">More lore awaits discovery...</p>`;
                }
            }
            loreModalContent.innerHTML = contentHTML;
            if (loreModal) loreModal.classList.remove('hidden');
        }

        if (closeLoreModalButton && loreModal) closeLoreModalButton.addEventListener('click', () => loreModal.classList.add('hidden'));
        if (loreModal) loreModal.addEventListener('click', (e) => { if (e.target === loreModal) loreModal.classList.add('hidden'); });

        // --- "HOW TO PLAY" & HELP MODAL ---
        const howToPlayModal = document.getElementById('how-to-play-modal');
        const closeHowToPlayModal = document.getElementById('close-how-to-play-modal');
        const gotItHowToPlayModal = document.getElementById('got-it-how-to-play-modal');
        const helpModal = document.getElementById('help-modal');
        const helpButton = document.getElementById('help-button');
        const closeHelpModal = document.getElementById('close-help-modal');

        if (closeHowToPlayModal && gotItHowToPlayModal && howToPlayModal) {
            const dismissModal = () => {
                howToPlayModal.classList.add('hidden');
                localStorage.setItem('hasSeenHowToPlay_v1', 'true');
                TutorialManager.checkState(); // Start coach marks after initial modal if not completed
            };
            closeHowToPlayModal.addEventListener('click', dismissModal);
            gotItHowToPlayModal.addEventListener('click', dismissModal);
        }
        if(helpButton && helpModal && closeHelpModal) {
            helpButton.addEventListener('click', () => helpModal.classList.remove('hidden'));
            closeHelpModal.addEventListener('click', () => helpModal.classList.add('hidden'));
            helpModal.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.classList.add('hidden'); });
        }


        // --- DOMAIN DEFINITIONS ---
        // (defineAllDomains function with all domain data including lore)
        // This function is very long and mostly unchanged from the previous version where lore was added.
        // Ensure all `id` attributes on clickable elements are correct for tutorial selectors.
        function defineAllDomains() {
            Game.resources_map = {
                'probabilityPetal': { name: 'Petals' }, 'echoRoyalty': { name: 'Echoes' }, 'flavorQuark': { name: 'Quarks' },
                'existentialStamp': { name: 'Stamps' }, 'symmetryShard': { name: 'Shards' }, 'chronoTip': { name: 'Tips' },
                'vibeOre': { name: 'Vibes' }
            };

            defineDomain({
                id: 'gardeners', name: 'Quantum Gardeners', color: '#34D399', description: 'Tend probability-plants. They cultivate chance itself in the Probabilistic Grove.',
                allLoreTexts: [
                    "A rogue quantum computer, cornered in a collapsing lab, folded itself into a pocket reality of pure superposition. Its maintenance nanobots bloomed into the first Gardeners.",
                    "Nanobots discover chlorophyll‑like photonic cells, letting plants photosynthesize probability instead of photons. Visitors hear dice roll whenever the vines rustle.",
                    "Hourglass sprites hatch from discarded CPU heat sinks; they regulate causal flow the way bees pollinate flowers.",
                    "Garden paths split into Schrödinger fork‑roads—walking left and right simultaneously increases Petal yield by √2.",
                    "Collapsing a rival’s certainty leaks Entropy Dew, which Gardeners bottle as fertilizer. Side‑effect: nearby clocks stutter.",
                    "A Quantum Greenhouse appears, its glass panes switching between wave and particle transparency. Tourists must sign a liability waiver for “temporal splinters.”",
                    "Sonic pruning shears tune plant harmonics; petals hum perfect fifths that double growth. The Grove hums like a cosmic harp.",
                    "The Many‑Worlds Orchard opens: fruit contains seed‑universes. Squeezing one grants a random passive buff or releases a minor paradox.",
                    "Gardener elders weave a Probability Mantle that shields timelines from hostile audits, reducing future sabotage by 10%.",
                    "Gardeners transcend botany, grafting reality stems directly onto entropy’s root. They can now “re‑bloom” collapsed timelines for permanent global multipliers."
                ],
                clickResource: { id: 'probabilityPetal', name: 'Petals', baseAmount: 1 },
                generators: [{ id: 'timelineBloomer', name: 'Timeline Bloomer', baseCost: { probabilityPetal: 10 }, costScaling: 1.15, baseProd: { probabilityPetal: 0.1 }, prodScaling: 1.1, description: 'Sprites for your garden.' }],
                abilities: [{ id: 'collapseCertainty', name: 'Collapse Certainty', type: 'aggressive', cost: { probabilityPetal: 100 }, cooldownMs: 30000, strainFactor: 5, effect: (caster, target) => { if (!target) return; addBuff({ id: `certaintyCollapse_${target.id}`, replacesExisting: true, domainId: target.id, durationMs: 10000, affects: 'production', multiplier: 0.5, description: `${target.name}'s production halved!`, onApply: () => Bus.emit('feedback:message', {message: `${target.name}'s production collapsed!`, type: 'warning'}), onEnd: () => Bus.emit('feedback:message', {message: `${target.name}'s production restored.`, type: 'info'}) }); Bus.emit('feedback:message', {message: `Certainty collapsed for ${target.name}!`, type: 'success'}); }, description: 'Reduce rival\'s production by 50%.', requiresTarget: true }]
            });

            defineDomain({
                id: 'soundwaves', name: 'Sentient Soundwaves', color: '#60A5FA', description: 'Interdimensional record label from the Resonance Rift, where music is reality.',
                allLoreTexts: [
                    "Between the Big Bang’s heartbeats, free‑floating vibrations gained self‑awareness and vowed never to be silent again.",
                    "Soundwaves invent Crystal Earphones that stream emotion‑encoded chords to every dimension, attracting new frequencies.",
                    "“Bass‑Drop Billow” signs a single‑note contract; the note lasts three hours and bends local gravity in sync with the beat.",
                    "Rift architects carve Amp‑Cathedrals whose spires refract sonic pressure into colored auroras. Clicks now leave cymbal sparks.",
                    "Dissonance tears micro‑holes in quietude; silence leaks out as tangible black shards worth 5× Echo value when collected.",
                    "The Chorus Collective premieres a song so catchy it loops itself into the past, retroactively doubling your first 10k Echoes.",
                    "Joy‑nugget resonance creates Euphonic Alloy—a crafting‑grade material that buffs both Vibes and Echoes by 20%.",
                    "A rogue sub‑bass line becomes sentient and legally divorces its parent track, causing a lawsuit that produces lucrative publicity.",
                    "Soundwaves invent Noise‑Cancelling Reality Foam that temporarily halves incoming Strain.",
                    "The Rift composes the Grand Unified Melody, syncing every Domain’s tick to a cosmic metronome and granting a permanent +5% global production."
                ],
                clickResource: { id: 'echoRoyalty', name: 'Echoes', baseAmount: 1 },
                generators: [{ id: 'cosmicArtist', name: 'Cosmic Artist', baseCost: { echoRoyalty: 12 }, costScaling: 1.16, baseProd: { echoRoyalty: 0.12 }, prodScaling: 1.1, description: 'Soundwave beings jam.'}],
                abilities: [{ id: 'dissonanceBurst', name: 'Dissonance Burst', type: 'aggressive', cost: { echoRoyalty: 120 }, cooldownMs: 45000, strainFactor: 6, effect: (caster, target) => { if(!target) return; addBuff({id: `dissonance_${target.id}`, replacesExisting: true, domainId: target.id, durationMs: 15000, affects: 'click', multiplier: 0.25, description: `${target.name}'s click power scrambled!`, onApply: ()=> Bus.emit('feedback:message', {message: `${target.name}'s clicks dissonant!`, type:'warning'}), onEnd: ()=> Bus.emit('feedback:message', {message:`${target.name}'s clicks harmonic.`, type:'info'}) }); Bus.emit('feedback:message',{message:`Dissonance burst sent to ${target.name}!`,type:'success'});}, description: 'Scramble rival\'s click power by 75%.', requiresTarget: true}]
            });

            defineDomain({
                id: 'soup', name: 'Cosmic Soup Ladle', color: '#FBBF24', description: 'Stirring the Primordial Cauldron, one flavor-quark at a time.',
                allLoreTexts: [
                    "A utensil‑deity awakens, still tasting the flavor of nothingness. It refuses to retire until every atom is “properly seasoned.”",
                    "Discovery of Bouillon Stars—dense nuggets of quark‑flavor that melt into reality, altering physical laws to taste “spicier.”",
                    "Stirring produces Alphabet Particles; arranging them spells short-lived wishes that grant random buffs.",
                    "The Ladle spins fast enough to shear off Flavor Foam—usable by other Domains as a universal solvent.",
                    "Tasting rivals’ resources lets you map their flavor profiles; future Slurps gain +10% efficiency against already sampled Domains.",
                    "Invent Reverse‑Time Noodles that cook by getting cooler; eating one refunds your last 5 seconds of mis‑clicks.",
                    "Entropy Ramen hits the chrono‑menu, granting both Quark and Tip bonuses whenever served to the same patron twice in different eras.",
                    "The Ladle graduates to Cosmo‑Sommelier, detecting subtle “oaky strings” in spacetime and monetizing them as a luxury spice.",
                    "Rival chefs stage a Spoilage Rebellion. Defeating it unlocks Fermented Dark‑Matter Kimchi, a prestige‑era production boost.",
                    "The Cauldron’s broth reaches Flavor Equilibrium, letting you “season” any new timeline at creation, seeding it with 1% of your Quark total."
                ],
                clickResource: { id: 'flavorQuark', name: 'Quarks', baseAmount: 1 },
                generators: [{id: 'primordialBroth', name: 'Primordial Broth', baseCost: {flavorQuark: 15}, costScaling: 1.17, baseProd: {flavorQuark: 0.15}, prodScaling: 1.1, description: 'Simmers quarks.'}],
                abilities: [{id: 'bigSlurp', name: 'Big Slurp', type: 'utility', cost: {flavorQuark: 200}, cooldownMs: 120000, strainFactor: 10, effect: (caster)=>{ let totalSlurpedToGain=0; Object.values(Game.domains).forEach(d=>{ if(d.id !== caster.id){ const amountSlurped = Game.getResource(d.clickResource.id)*0.05; Game.addResource(d.clickResource.id, -amountSlurped); totalSlurpedToGain += amountSlurped*0.5; Bus.emit('feedback:message',{message:`${caster.name} slurped ${formatNumber(amountSlurped)} ${d.clickResource.name} from ${d.name}!`, type:'warning'});}}); Game.addResource(caster.clickResource.id, totalSlurpedToGain); Bus.emit('feedback:message',{message:`Big Slurp! Gained ${formatNumber(totalSlurpedToGain)} ${caster.clickResource.name}!`, type:'success'});}, description: 'Drain 5% of others\' resources, keep half.', requiresTarget: false}]
            });

            defineDomain({
                id: 'afterlives', name: 'Bureaucratic Afterlives', color: '#A78BFA', description: 'Processing souls in Clerical Purgatoria. Paperwork is eternal.',
                allLoreTexts: [
                    "Unanswered prayers condensed into paperwork; self‑aware forms demanded clerks, so ghosts applied.",
                    "Spectral staplers go on strike; the Bureau legalizes Paperclips of Binding that keep ghouls docile and speed filing by 5%.",
                    "The clerk’s first act: file a complaint about its own working conditions, spawning an eternal feedback loop that generates bonus Stamps.",
                    "Infinite In‑Tray discovered; it autofills with forms from futures where you never existed. Processing them grants paradox insurance.",
                    "Late fees crystallize into Debt‑Gremlins; if you click them they squeal and drop extra resources.",
                    "The Bureau adopts Quantum Paperwork that is simultaneously approved and denied, cutting cooldowns in half.",
                    "Petals used as eco‑friendly ink; green paperwork boosts Garden production while filing.",
                    "Clerks unionize, forming GhOST (Local 404); concessions include coffee breaks that double Stamps during idle periods.",
                    "You earn honorary title “Under‑Secretary of Metaphysical Compliance,” unlocking a passive 2% tax on all rival resource gains.",
                    "The Bureau resolves its original backlog. New existential forms auto‑generate from dreams, granting permanent +1 Entropy Token per Collapse."
                ],
                clickResource: { id: 'existentialStamp', name: 'Stamps', baseAmount: 1 },
                generators: [{id: 'soulClerk', name: 'Soul Clerk', baseCost: {existentialStamp: 20}, costScaling: 1.18, baseProd: {existentialStamp: 0.2}, prodScaling: 1.1, description: 'Ghosts with staplers.'}],
                abilities: [{id: 'auditRival', name: 'Audit Rival', type: 'aggressive', cost: {existentialStamp: 150}, cooldownMs: 60000, strainFactor: 7, effect: (caster, target)=>{if(!target) return; addBuff({id: `audit_${target.id}`, replacesExisting: true, domainId: target.id, durationMs: 30000, customEffect: true, description: `${target.name} audited! Costs up 50%.`, onApply: (game, domainId)=>{ const tDomain = game.domains[domainId]; tDomain.generators.forEach(g=>g.costMultiplier=(g.costMultiplier||1)*1.5); Bus.emit('feedback:message',{message:`${target.name} audited! Costs up!`,type:'warning'}); updateDomainUICard(target.id);}, onEnd: (game, domainId)=>{ const tDomain = game.domains[domainId]; tDomain.generators.forEach(g=>g.costMultiplier=(g.costMultiplier||1)/1.5); Bus.emit('feedback:message',{message:`Audit for ${target.name} ended.`,type:'info'}); updateDomainUICard(target.id);}}); Bus.emit('feedback:message',{message:`Audit for ${target.name}!`,type:'success'});}, description: 'Increase rival\'s upgrade costs by 50%.', requiresTarget: true}]
            });

            defineDomain({
                id: 'fractals', name: 'Fractal Friend Factory', color: '#F472B6', description: 'Forging self-similar companions in the Kaleidoscopic Forge.',
                allLoreTexts: [
                    "Runaway self‑similarity forged a workshop at Mandelbrot’s edge; patterns smelt patterns here.",
                    "Tessellators invent Recursive Clay, folding on itself to produce smaller copies until gently observed.",
                    "Möbius Cat named “Whisk∞rs” chases its own tail and generates a 1% click multiplier every loop.",
                    "Factory overflows create a second‑order hallway—walking down it returns you younger by one click.",
                    "Stolen matter reveals hidden Mirror Caches in rival Domains; claiming one grants bonus shards equal to 2× theft amount.",
                    "Unlock Symmetry Hatchery where pets breed derivative pets, compounding shard income exponentially.",
                    "Infinite fern grafted onto probability vines yields Phyllotactic Petals worth both Petals and Shards.",
                    "Discover Negative‑Dimension Storage, doubling Shard cap and enabling offline gains during game‑close.",
                    "Factory folds inside out, revealing Antifractals that neutralize hostile buffs once per minute.",
                    "Patterns achieve sentience and vote to unionize; each pet now spawns a microscopic civil‑society that grants permanent +5% global click power."
                ],
                clickResource: { id: 'symmetryShard', name: 'Shards', baseAmount: 1 },
                generators: [{id: 'fractalPet', name: 'Fractal Pet', baseCost: {symmetryShard: 25}, costScaling: 1.19, baseProd: {symmetryShard: 0.25}, prodScaling: 1.1, description: 'Self-similar critters.'}],
                abilities: [{id: 'recursiveSwarm', name: 'Recursive Swarm', type: 'aggressive', cost: {symmetryShard: 180}, cooldownMs: 75000, strainFactor: 8, effect: (caster, target)=>{if(!target) return; const amountStolen = Game.getResource(target.clickResource.id)*0.10; Game.addResource(target.clickResource.id, -amountStolen); Game.addResource(caster.clickResource.id, amountStolen); Bus.emit('feedback:message',{message:`Swarm stole ${formatNumber(amountStolen)} ${target.clickResource.name} from ${target.name}!`,type:'success'});}, description: 'Steal 10% of rival\'s resource.', requiresTarget: true}]
            });

            defineDomain({
                id: 'snackbar', name: 'Time-Traveling Snack Bar', color: '#FB923C', description: 'Serving chrono-burgers and temporal fries at the Chrono-Cantina.',
                allLoreTexts: [
                    "A tachyon‑scooter chef opens a food truck that parks at extinction events and music festivals alike.",
                    "Install Temporal Deep‑Fryer—cooks food yesterday so it’s cooled by the time it’s served now.",
                    "Truck returns from Late Cretaceous with a suspiciously large grease stain shaped like a velociraptor thumbs‑up.",
                    "Add Chrono‑Condiments—ketchup that remembers being tomatoes next week, buffing Tips per click by 10%.",
                    "Surge leaves behind Tip Receipts dated tomorrows; caching them grants a burst of offline earnings when the date arrives.",
                    "Franchise opens in Renaissance Florence; Da Vinci sketches your menu, granting a creativity multiplier across all Domains.",
                    "Serve Entropy Ramen—guests who reorder in another era refund 50% of Paradox Surge cooldown.",
                    "Health inspectors from 3128 AD arrive; passing inspection unlocks Future‑Proof Realty, boosting building upgrades’ effectiveness.",
                    "Timeline lawyers issue Causality Insurance, preventing the next resource loss effect entirely.",
                    "Snack Bar attains Temporal Omnipresence—one truck exists at every timestamp, adding +1 global click per real‑time second logged in."
                ],
                clickResource: { id: 'chronoTip', name: 'Tips', baseAmount: 1 },
                generators: [{id: 'eraFoodTruck', name: 'Era Food Truck', baseCost: {chronoTip: 30}, costScaling: 1.20, baseProd: {chronoTip: 0.3}, prodScaling: 1.1, description: 'Dinosaur grease stains.'}],
                abilities: [{id: 'paradoxSurge', name: 'Paradox Surge', type: 'aggressive', cost: {chronoTip: 220}, cooldownMs: 90000, strainFactor: 9, effect: (caster, target)=>{if(!target) return; const currentAmount = Game.getResource(target.clickResource.id); const newAmount = currentAmount*0.10; Game.resources[target.clickResource.id]=newAmount; Bus.emit('resource:update',{resourceId: target.clickResource.id, amount: newAmount}); Bus.emit('feedback:message',{message:`Paradox Surge! ${target.name}'s ${target.clickResource.name} reverted to ${formatNumber(newAmount)}!`,type:'warning'});}, description: 'Revert rival\'s resource to 10%.', requiresTarget: true}]
            });

            defineDomain({
                id: 'emotions', name: 'Emotion Mining Co.', color: '#818CF8', description: 'Drilling for raw feelings in the Sentient Stratum. Vibes are valuable.',
                allLoreTexts: [
                    "Empath‑savants tap the dream‑bedrock, unearthing raw feeling crystals older than language.",
                    "Discover Regret Gas—inert alone, explosive when mixed with Hope Nuggets; miners wear mirrored helmets to deflect accidents.",
                    "Reactors refine feelings into Vibe Alloy, a psychic metal that shapes itself to its owner’s mood.",
                    "Mining depth reaches Subconscious Plateau, where archetypes roam like megafauna and occasionally drop rare Wonder Pelts.",
                    "Field pacifies the Plateau; archetypes curl up like house cats, granting 2× passive production during its duration.",
                    "Company issues Emotional Futures contracts; correctly guessing tomorrow’s global mood yields a 15% production windfall.",
                    "Joy crystals resonate, creating Harmony Echoes that convert 5% of Echo income to Vibes automatically.",
                    "Miners breach Nostalgia Vein—processing it lets you re‑roll one generator’s cost scaling per prestige.",
                    "Release of bottled Dread spawns Courage Plumes; collecting them reduces Strain by 5 instantly.",
                    "Stratum fully terraformed into a Psycho‑Crystal Garden: every future Collapse yields an extra global buff chosen at random."
                ],
                clickResource: { id: 'vibeOre', name: 'Vibes', baseAmount: 1 },
                generators: [{id: 'empathyReactor', name: 'Empathy Reactor', baseCost: {vibeOre: 35}, costScaling: 1.21, baseProd: {vibeOre: 0.35}, prodScaling: 1.1, description: 'Terraforms psyche-planet.'}],
                abilities: [{id: 'serenityField', name: 'Serenity Field', type: 'defensive', cost: {vibeOre: 250}, cooldownMs: 180000, strainFactor: 3, effect: (caster)=>{ addBuff({id: `serenityField_${caster.id}`, replacesExisting: true, domainId: caster.id, durationMs: 60000, affects: 'production', multiplier: 2.0, description: `${caster.name} protected! Production x2.`, onApply: ()=> Bus.emit('feedback:message',{message:`${caster.name} Serenity Field! Prod x2!`,type:'success'}), onEnd: ()=> Bus.emit('feedback:message',{message:`Serenity Field for ${caster.name} faded.`,type:'info'})});}, description: 'Boost own production by 100%.', requiresTarget: false}]
            });
        }
        
        // --- STORYLINE DEFINITIONS ---

        // Helper function to register lore events
        function registerLore(domainId, level, triggerFn, oneTime = true) {
            const domain = Game.domains[domainId];
            if (!domain || !domain.allLoreTexts || level > domain.allLoreTexts.length) {
                console.warn(`Lore registration failed: Domain ${domainId} or lore text for level ${level} not found.`);
                return;
            }
            const lorem = domain.allLoreTexts[level - 1]; // 0-indexed array
            const storyId = `${domainId}_lore_lvl${level}`;
            const message = `[${domain.name} Lore Lvl ${level}] ${lorem}`;

            addStoryEvent(
                storyId,
                triggerFn,
                message,
                oneTime,
                (game) => { // onFireAction
                    if (game.domains[domainId]) {
                        game.domains[domainId].unlockedLoreLevel = Math.max(game.domains[domainId].unlockedLoreLevel || 0, level);
                        Bus.emit('lore:unlocked', { domainId, level, newUnlockedLevel: game.domains[domainId].unlockedLoreLevel });
                    }
                }
            );
        }

        function defineStorylines() {
            // Standard Story Events
            addStoryEvent('genesis', () => Game.t > 1000, "A faint hum... The Conflux awakens. You feel an urge to... click?");
            addStoryEvent('firstPetalHundred', () => Game.getResource('probabilityPetal') >= 100 && (Game.domains.gardeners?.unlockedLoreLevel || 0) < 2, "Quantum Gardener: 'Each petal, a possibility.'"); // Example of tying old story to new lore system
            addStoryEvent('allDomainsActive', () => Object.values(Game.domains).every(d => d.generators.some(g => g.level > 0)) && !storyEvents.find(e=>e.id==='allDomainsActive')?.fired, "All seven Domains hum with activity. The Conflux is truly alive!");

            // --- Multi-Level Lore Event Definitions ---
            const getDomainLevel = (domainId) => (Game.domains[domainId]?.generators.reduce((s, g) => s + g.level, 0) || 0);

            // 🌱 Quantum Gardeners Lore
            registerLore('gardeners', 1, () => Game.getResource('probabilityPetal') > 0);
            registerLore('gardeners', 2, () => Game.getResource('probabilityPetal') >= 100);
            registerLore('gardeners', 3, () => Game.domains.gardeners?.generators.find(g => g.id === 'timelineBloomer')?.level >= 1);
            registerLore('gardeners', 4, () => getDomainLevel('gardeners') >= 10);
            registerLore('gardeners', 5, () => Game.storyFlags.gardeners_castCollapseCertaintyOnce === true);
            registerLore('gardeners', 6, () => Game.domains.gardeners?.generators.find(g => g.id === 'timelineBloomer')?.level >= 25);
            registerLore('gardeners', 7, () => getDomainLevel('gardeners') >= 25 && getDomainLevel('soundwaves') >= 25);
            registerLore('gardeners', 8, () => getDomainLevel('gardeners') >= 50);
            registerLore('gardeners', 9, () => Game.storyFlags.rivalsTargetedByAbilities.size >= 5);
            registerLore('gardeners', 10, () => getDomainLevel('gardeners') >= 100);

            // 🎵 Sentient Soundwaves Lore
            registerLore('soundwaves', 1, () => Game.getResource('echoRoyalty') > 0);
            registerLore('soundwaves', 2, () => Game.getResource('echoRoyalty') >= 100);
            registerLore('soundwaves', 3, () => Game.domains.soundwaves?.generators.find(g => g.id === 'cosmicArtist')?.level >= 1);
            registerLore('soundwaves', 4, () => getDomainLevel('soundwaves') >= 10);
            registerLore('soundwaves', 5, () => Game.storyFlags.soundwaves_castDissonanceBurstOnce === true);
            registerLore('soundwaves', 6, () => Game.domains.soundwaves?.generators.find(g => g.id === 'cosmicArtist')?.level >= 25);
            registerLore('soundwaves', 7, () => getDomainLevel('soundwaves') >= 25 && getDomainLevel('emotions') >= 25);
            registerLore('soundwaves', 8, () => getDomainLevel('soundwaves') >= 50);
            registerLore('soundwaves', 9, () => Game.realityStrain / Game.maxRealityStrain >= 0.6);
            registerLore('soundwaves', 10, () => getDomainLevel('soundwaves') >= 100);

            // 🍲 Cosmic Soup Ladle Lore
            registerLore('soup', 1, () => Game.getResource('flavorQuark') > 0);
            registerLore('soup', 2, () => Game.getResource('flavorQuark') >= 1000);
            registerLore('soup', 3, () => Game.domains.soup?.generators.find(g => g.id === 'primordialBroth')?.level >= 1);
            registerLore('soup', 4, () => getDomainLevel('soup') >= 10);
            registerLore('soup', 5, () => Game.storyFlags.soup_castBigSlurpOnce === true);
            registerLore('soup', 6, () => Game.domains.soup?.generators.find(g => g.id === 'primordialBroth')?.level >= 25);
            registerLore('soup', 7, () => getDomainLevel('soup') >= 25 && getDomainLevel('snackbar') >= 25);
            registerLore('soup', 8, () => getDomainLevel('soup') >= 50);
            registerLore('soup', 9, () => Game.storyFlags.soup_slurpsThisPrestige >= 3);
            registerLore('soup', 10, () => getDomainLevel('soup') >= 100);

            // 📑 Bureaucratic Afterlives Lore
            registerLore('afterlives', 1, () => Game.getResource('existentialStamp') > 0);
            registerLore('afterlives', 2, () => Game.getResource('existentialStamp') >= 100);
            registerLore('afterlives', 3, () => Game.domains.afterlives?.generators.find(g => g.id === 'soulClerk')?.level >= 1);
            registerLore('afterlives', 4, () => getDomainLevel('afterlives') >= 10);
            registerLore('afterlives', 5, () => Game.storyFlags.afterlives_castAuditRivalOnce === true);
            registerLore('afterlives', 6, () => Game.domains.afterlives?.generators.find(g => g.id === 'soulClerk')?.level >= 25);
            registerLore('afterlives', 7, () => getDomainLevel('afterlives') >= 25 && getDomainLevel('gardeners') >= 25);
            registerLore('afterlives', 8, () => getDomainLevel('afterlives') >= 50);
            registerLore('afterlives', 9, () => Game.storyFlags.afterlives_auditedRivals.size >= 5);
            registerLore('afterlives', 10, () => getDomainLevel('afterlives') >= 100);

            // 🔷 Fractal Friend Factory Lore
            registerLore('fractals', 1, () => Game.getResource('symmetryShard') > 0);
            registerLore('fractals', 2, () => Game.getResource('symmetryShard') >= 100);
            registerLore('fractals', 3, () => Game.domains.fractals?.generators.find(g => g.id === 'fractalPet')?.level >= 1);
            registerLore('fractals', 4, () => getDomainLevel('fractals') >= 10);
            registerLore('fractals', 5, () => Game.storyFlags.fractals_castRecursiveSwarmOnce === true);
            registerLore('fractals', 6, () => Game.domains.fractals?.generators.find(g => g.id === 'fractalPet')?.level >= 25);
            registerLore('fractals', 7, () => getDomainLevel('fractals') >= 25 && getDomainLevel('gardeners') >= 25);
            registerLore('fractals', 8, () => getDomainLevel('fractals') >= 50);
            registerLore('fractals', 9, () => Game.realityStrain / Game.maxRealityStrain >= 0.7);
            registerLore('fractals', 10, () => getDomainLevel('fractals') >= 100);

            // ⏰ Time-Traveling Snack Bar Lore
            registerLore('snackbar', 1, () => Game.getResource('chronoTip') > 0);
            registerLore('snackbar', 2, () => Game.getResource('chronoTip') >= 100);
            registerLore('snackbar', 3, () => Game.domains.snackbar?.generators.find(g => g.id === 'eraFoodTruck')?.level >= 1);
            registerLore('snackbar', 4, () => getDomainLevel('snackbar') >= 10);
            registerLore('snackbar', 5, () => Game.storyFlags.snackbar_castParadoxSurgeOnce === true);
            registerLore('snackbar', 6, () => Game.domains.snackbar?.generators.find(g => g.id === 'eraFoodTruck')?.level >= 25);
            registerLore('snackbar', 7, () => getDomainLevel('snackbar') >= 25 && getDomainLevel('soup') >= 25);
            registerLore('snackbar', 8, () => getDomainLevel('snackbar') >= 50);
            registerLore('snackbar', 9, () => Game.storyFlags.snackbar_surgesThisPrestige >= 3);
            registerLore('snackbar', 10, () => getDomainLevel('snackbar') >= 100);

            // 💠 Emotion Mining Co. Lore
            registerLore('emotions', 1, () => Game.getResource('vibeOre') > 0);
            registerLore('emotions', 2, () => Game.getResource('vibeOre') >= 100);
            registerLore('emotions', 3, () => Game.domains.emotions?.generators.find(g => g.id === 'empathyReactor')?.level >= 1);
            registerLore('emotions', 4, () => getDomainLevel('emotions') >= 10);
            registerLore('emotions', 5, () => Game.storyFlags.emotions_castSerenityFieldOnce === true);
            registerLore('emotions', 6, () => Game.domains.emotions?.generators.find(g => g.id === 'empathyReactor')?.level >= 25);
            registerLore('emotions', 7, () => getDomainLevel('emotions') >= 25 && getDomainLevel('soundwaves') >= 25);
            registerLore('emotions', 8, () => getDomainLevel('emotions') >= 50);
            registerLore('emotions', 9, () => Game.realityStrain / Game.maxRealityStrain >= 0.9);
            registerLore('emotions', 10, () => getDomainLevel('emotions') >= 100);

            // Tutorial Related Story Hints
            addStoryEvent('tutorialIdleHint',
                () => Game.t > 120000 && Game.prestigeCount === 0 && Game.domains.gardeners?.generators.find(g=>g.id==='timelineBloomer')?.level > 0 && !localStorage.getItem('tutorialFullyCompleted_v1'),
                "Hint: Your Generators work even when you're not actively clicking. Check back later to see your earnings!", 
                false // Repeatable until tutorial is done
            );
            addStoryEvent('tutorialStrainHint', 
                () => Game.realityStrain > Game.maxRealityStrain * 0.6 && Game.prestigeCount === 0 && !localStorage.getItem('tutorialFullyCompleted_v1'),
                "Hint: Reality Strain is getting high! Soon you'll be able to 'Conflux Collapse' for powerful Entropy Tokens.", 
                false 
            );
        }

        // --- GAME LOOP ---
        let animationFrameId = null;
        function gameLoop() {
            const now = Date.now(); const dtMs = now - Game.lastUpdate; Game.lastUpdate = now;
            tick(dtMs); checkStoryEvents(); 
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // --- INITIALIZATION ---
        window.onload = () => {
            defineAllDomains(); defineStorylines(); renderAllDomains(); updateGlobalStatsUI();
            if(prestigeButton) prestigeButton.addEventListener('click', attemptPrestige);

            // Quick-Start Tagline (Layer 1)
            if (quickStartTagline) {
                if (!localStorage.getItem('hasPlayedBefore_v1')) {
                    quickStartTagline.innerHTML = "Click a Domain → Buy Generators → Use Abilities → Max Strain → Collapse for Tokens!";
                    quickStartTagline.classList.add('font-bold', 'text-lg'); // More prominent for first time
                } else {
                    quickStartTagline.innerHTML = "Shape the Conflux: Click. Automate. Collapse. Evolve.";
                }
                localStorage.setItem('hasPlayedBefore_v1', 'true');
            }

            // "How to Play" Modal (Layer 2)
            if (howToPlayModal && !localStorage.getItem('hasSeenHowToPlay_v1')) {
                howToPlayModal.classList.remove('hidden');
            } else {
                 TutorialManager.checkState(); // If initial modal skipped, start coach marks
            }
            
            Game.lastUpdate = Date.now(); 
            if (animationFrameId) cancelAnimationFrame(animationFrameId); 
            gameLoop(); 
            Bus.emit('feedback:message', { message: "Welcome to the Omnidimensional Conflux!", type: 'info', fontClass: 'font-arcade' });
        };
    </script>
</body>
</html>
